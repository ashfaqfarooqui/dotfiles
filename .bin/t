#!/usr/bin/env python

import os, re, sys, string, hashlib
from operator import itemgetter
from optparse import OptionParser as op, OptionGroup as og

# Constants

home = os.getenv('HOME')
taskdir = os.path.join(home, '.tasks')
taskfilename = 'tasks'
_alphabet = list(string.lowercase)

# Exceptions

class InvalidTaskfile(Exception):
    """Raised when the path to a task file already exists as a directory."""
    pass

class AmbiguousPrefix(Exception):
    """Raised when trying to use a prefix that could identify multiple tasks."""
    def __init__(self, prefix):
        super(AmbiguousPrefix, self).__init__()
        self.prefix = prefix

class UnknownPrefix(Exception):
    """Raised when trying to use a prefix that does not match any tasks."""
    def __init__(self, prefix):
        super(UnknownPrefix, self).__init__()
        self.prefix = prefix

# Functions

def _taskid(text, tasks):
    """
    Return an id for new tasks.
    """
    ids = []

    with open(tasks, "a+") as f:
        lines = f.readlines()
        for line in lines:
            num = float(line.split(":")[1].strip())
            if num%1. == 0:
                ids.append(num)

    for i in range(1,1000):
        if float(i) not in ids:
            return float(i)

def _subtaskid(text, mainid, tasks):
    """
    Return an id for new subtasks.
    """

    ids = []

    with open(tasks, "a+") as f:
        for line in f.readlines():
            num = line.split(":")[1].strip().split(".")
            if num[0] == mainid:
                ids.append(int(num[1]))

    for i in range(1,len(_alphabet)):
        if i not in ids:
            return i

def _get_mainids(tasks):
    """
    Returns a list containing currently used ids
    """

    ids = []

    with open(tasks, "r") as f:
        for line in f.readlines():
            num = float(line.split(":")[1].strip())
            if num%1. == 0:
                ids.append(num)
    return ids

def _task_from_line(taskline):
    """
    Parse a line from the tasks file and return the task.

    A taskline should be in the format:

        summary text ... | meta1:meta1_value,meta2:meta2_value,...

    The task returned will be a dictionary such as:

        { 'id': <hash id>,
          'text': <summary text>,
           ... other metadata ... }

    A taskline can also consist of only summary text, in which case the id
    and other metadata will be generated when the line is read.  This is
    supported to enable editing of the taskfile with a simple text editor.
    """

    # Ignores lines that are "commented out"
    if taskline.strip().startswith('#'):
        return None
    elif '|' in taskline:
        text, _, meta = taskline.rpartition('|')
        task = { 'text': text.strip() }
        for piece in meta.strip().split(','):
            label, data = piece.split(':')
            task[label.strip()] = data.strip()
    else:
        text = taskline.strip()
        task = { 'id': _taskid(), 'text': text }
    return task

def _tasklines_from_tasks(tasks):
    """
    Change tasks in plaintext form into a line to be written to file
    """

    tasklines = []

    for task in tasks:
        meta = [m for m in task.items() if m[0] != 'text']
        meta_str = ', '.join('%s:%s' % m for m in meta)
        tasklines.append('%s | %s\n' % (task['text'], meta_str))

    return tasklines

def _prefixes(ids):
    """
    Return a mapping of ids to prefixes in O(n) time.

    Each prefix will be the shortest possible substring of the ID that
    can uniquely identify it among the given group of IDs.

    If an ID of one task is entirely a substring of another task's ID, the
    entire ID will be the prefix.
    """

    ps = []
    for id in ids:
        if float(id)%1. == 0:
            ps.append((id.split(".")[0], id))
        else:
            subid = id.split(".")
            prefix = "  " + _alphabet[int(subid[1])-1]
            ps.append((prefix, id))
    return ps

def _ideval(prefix):
    """
    Determine the numeric id for a prefix, even when the prefix
    is a combination of letters and numbers.
    """

    main = ""
    sub = ""
    for i in range(0,len(prefix)):
        try:
            int(prefix[i])
            main += prefix[i]
        except ValueError:
            sub += prefix[i]

    if sub:
        for i in range(0,len(_alphabet)):
            if sub == _alphabet[i]:
                sub = str(i+1)
    else:
        sub += "0"

    return main + "." + sub

# Task Object

class TaskDict(object):
    """A set of tasks, both finished and unfinished, for a given list.

    The list's files are read from disk when the TaskDict is initialized. They
    can be written back out to disk with the write() function.

    """

    def __init__(self, taskdir, name):
        """Initialize by reading the task files."""
        self.tasks = {}
        self.done = {}
        self.name = name
        self.taskdir = taskdir
        filemap = (('tasks', self.name), ('done', '%s.done' % self.name))
        for kind, filename in filemap:
            path = os.path.join(self.taskdir, filename)
            if os.path.isdir(path):
                raise InvalidTaskfile
            if os.path.exists(path):
                with open(path, 'r') as tfile:
                    tls = [tl.strip() for tl in tfile if tl]
                    tasks = map(_task_from_line, tls)
                    for task in tasks:
                        if task is not None:
                            getattr(self, kind)[task['id']] = task

    def __getitem__(self, prefix):
        """
        Return the unfinished task with the given prefix.

        If more than one task matches the prefix an AmbiguousPrefix exception
        will be raised, unless the prefix is the entire ID of one task.

        If no tasks match the prefix an UnknownPrefix exception will be raised.

        """
        matched = filter(lambda tid: tid.startswith(prefix), self.tasks.keys())
        if len(matched) == 1:
            return self.tasks[matched[0]]
        elif len(matched):
            raise UnknownPrefix(prefix)
        else:
            matched = filter(lambda tid: tid == prefix, self.tasks.keys())
            if len(matched) == 1:
                return self.tasks[matched[0]]
            else:
                raise AmbiguousPrefix(prefix)

    def add_task(self, text):
        """
        Add a new, unfinished task with the given summary text.
        """
        path = os.path.join(self.taskdir, self.name)
        task_id = _taskid(text, path)
        self.tasks[task_id] = {'id': task_id, 'text': text}

    def add_subtask(self, prefix, text):
        """
        Add a new subtask to an unfinished main task.
        """
        try:
            int(prefix)
        except ValueError:
            raise UnknownPrefix(prefix)
        path = os.path.join(self.taskdir, self.name)
        if float(prefix) not in _get_mainids(path):
            raise UnknownPrefix(prefix)
        subtask_id = _subtaskid(text, prefix, tasks)
        subtask_id = prefix + "." + str(subtask_id)
        self.tasks[str(subtask_id)] = {'id': subtask_id, 'text': text}

    def edit_task(self, prefix, text):
        """
        Edit the task with the given prefix.

        If more than one task matches the prefix an AmbiguousPrefix exception
        will be raised, unless the prefix is the entire ID of one task.

        If no tasks match the prefix an UnknownPrefix exception will be raised.

        """
        prefix = _ideval(prefix)
        task = self[prefix]
        if text.startswith('s/') or text.startswith('/'):
            text = re.sub('^s?/', '', text).rstrip('/')
            find, _, repl = text.partition('/')
            text = re.sub(find, repl, task['text'])

        task['text'] = text

    def finish_task(self, prefix):
        """
        Mark the task of the given prefix as finished.

        If more than one task matches the prefix, an AmbiguousPrefix exception
        will be raised. If no tasks match it, an UnknownPrefix exception will
        be raised.
        """
        prefix = _ideval(prefix)
        task = self.tasks.pop(self[prefix]['id'])
        self.done[task['id']] = task

    def remove_task(self, prefix):
        """
        Remove the task of the given prefix from the tasks list.

        If more than one task matches the prefix, an AmbiguousPrefix exception
        will be raised. If no tasks match it, an UnknownPrefix exception will
        be raised.
        """
        prefix = _ideval(prefix)
        self.tasks.pop(self[prefix]['id'])

    def print_list(self, kind='tasks', verbose=False, quiet=False, grep=''):
        """
        Print out a nicely formatted list of unfinished tasks.
        """
        tasks = dict(getattr(self, kind).items())
        label = 'prefix' if not verbose else 'id'

        maintask = []
        subtasks = []

        if not verbose:
            for prefix, task_id in _prefixes(tasks):
                tasks[task_id]['prefix'] = prefix

        for task in tasks.values():
            if float(task['id'])%1. == 0:
                maintask.append(task)
            else:
                subtasks.append(task)

        padmain = max(map(lambda t: len(t[label]), maintask)) if maintask else 0
        padsub = max(map(lambda t: len(t[label]), subtasks)) if subtasks else 0
        for task_id, task in sorted(tasks.items()):
            if grep.lower() in task['text'].lower():
                if float(task_id)%1. == 0:
                    p = '%s - ' %task[label].ljust(padmain) if not quiet else ''
                else:
                    p = '%s - ' %task[label].ljust(padsub) if not quiet else '  '
                print p + task['text']

    def write(self, delete_if_empty=False):
        """
        Flush the finished and unfinished tasks to the files on disk.
        """
        filemap = (('tasks', self.name), ('done', '%s.done' % self.name))
        for kind, filename in filemap:
            path = os.path.join(self.taskdir, filename)
            if os.path.isdir(path):
                raise InvalidTaskfile
            tasks = sorted(getattr(self, kind).values(), key=itemgetter('id'))
            if tasks or not delete_if_empty:
                with open(path, 'w') as tfile:
                    for taskline in _tasklines_from_tasks(tasks):
                        tfile.write(taskline)
            elif not tasks and os.path.isfile(path):
                os.remove(path)

# Option Parser

def _build_parser():
    """
    Return parsed arguments from the command line.
    """
    usage = "Usage: %prog [-t DIR] [-l LIST] [options] [TEXT]"
    parser = op(usage=usage)

    actions = og(parser, "Actions",
                 "If no actions are specific, [TEXT] will be added as a new task.")
    actions.add_option("-e", "--edit", dest="edit", default="",
                       help="edit TASK to contain [TEXT]", metavar="TASK")
    actions.add_option("-f", "--finish", dest="finish",
                       help="mark TASK as finished", metavar="TASK")
    actions.add_option("-r", "--remove", dest="remove",
                       help="Remove TASK from list", metavar="TASK")
    actions.add_option("-s", "--sub", dest="subtask",
                       help="Add a subtask to TASK", metavar="TASK")
    parser.add_option_group(actions)

    config = og(parser, "Configuration Options")
    config.add_option("-l", "--list", dest="name", default=taskfilename,
                      help="work on LIST", metavar="LIST")
    config.add_option("-t", "--task-dir", dest="taskdir", default=taskdir,
                      help="work on the lists in DIR", metavar="DIR")
    config.add_option("-d", "--delete-if-empty",
                      action="store_true", dest="delete", default=False,
                      help="delete the task file if it becomes empty")
    parser.add_option_group(config)

    output = og(parser, "Output Options")
    output.add_option("-g", "--grep", dest="grep", default='',
                      help="print only tasks that contain WORD", metavar="WORD")
    output.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print more detailed output (full task ids, etc)")
    output.add_option("-q", "--quiet",
                      action="store_true", dest="quiet", default=False,
                      help="print less detailed output (no task ids, etc)")
    output.add_option("--done",
                      action="store_true", dest="done", default=False,
                      help="list done tasks instead of unfinished ones")
    parser.add_option_group(output)

    return parser

# Main Function
def _main():
    """
    Run the command-line interface.
    """
    (options, args) = _build_parser().parse_args()

    td = TaskDict(taskdir=options.taskdir, name=options.name)
    text = ' '.join(args).strip()

    try:
        if options.finish:
            td.finish_task(options.finish)
            td.write(options.delete)
        elif options.remove:
            td.remove_task(options.remove)
            td.write(options.delete)
        elif options.edit:
            td.edit_task(options.edit, text)
            td.write(options.delete)
        elif options.subtask:
            td.add_subtask(options.subtask, text)
            td.write(options.delete)
        elif text:
            td.add_task(text)
            td.write(options.delete)
        else:
            kind = 'tasks' if not options.done else 'done'
            td.print_list(kind=kind, verbose=options.verbose, quiet=options.quiet,
                          grep=options.grep)
    except AmbiguousPrefix, e:
        sys.stderr.write('The ID "%s" matches more than one task.\n' % e.prefix)
    except UnknownPrefix, e:
        sys.stderr.write('The ID "%s" does not match any task.\n' % e.prefix)

if __name__ == '__main__':
    _main()
